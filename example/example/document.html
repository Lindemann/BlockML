<!DOCTYPE html>
<!--
    ____  __           __   __  _____
   / __ )/ /___  _____/ /__/  |/  / /
  / __  / / __ \/ ___/ //_/ /|_/ / /
 / /_/ / / /_/ / /__/ ,< / /  / / /___
/_____/_/\____/\___/_/|_/_/  /_/_____/

-->
<html>
	<head>
		<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
		<link type="image/x-icon" href="images/favicon.ico" rel="icon">
		<link media="screen" href="css/screen.css" type="text/css" rel="stylesheet">
		<link media="print" href="css/print.css" type="text/css" rel="stylesheet">
		<script src="highlight/highlight.pack.js"></script>
		<script>hljs.tabReplace = '    ';hljs.initHighlightingOnLoad();</script>
		<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'],['\\(','\\)']], processClass: 'math', ignoreClass: 'no-math'}});
		</script>
		<title>Recap of John McCarthy's Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I</title>
	</head>
	<body class="no-math">
		<div class="document_head">
			<h1 id="title">Recap of John McCarthy's Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I</h1>
			<h3>Judith Lindemann</h3>
			<h5>Berlin, 25 December 2013</h5>
		</div>
		<h1>Preface</h1>
		<p>This text is originated as an exercise for an university course about scientific writing at the Beuth University of Applied Sciences Berlin. The assignment was to choose a computer science paper, reproduce the key ideas in own words, and add some own thoughts about that topic as conclusion. </p>
		<p>I have selected the classical paper "<span class="bold">Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I</span>" by John McCarthy from 1960 (<a id="bib-LISP" href="#id-LISP">[LISP]</a>), because it permits a fascinating look into the history of programming languages and is the origin of many concepts that are still relevant today. </p>
		<p>This text is also influenced by Paul Graham's article "<span class="bold">Roots of Lisp</span>" from 2002 (<a id="bib-ROOTS" href="#id-ROOTS">[ROOTS]</a>) about that McCarthy paper. I follow Paul Graham's approach to provide code examples in actual LISP code instead of m-expressions, and I assume that <span class="code">quote</span> and <span class="code">cond</span> are elementary functions.</p>
		<div id="toc">
			<h1>Contents</h1>
			<ul>
				<li><span><span>1 Introduction</span></span><a href="#sec-1"><span>[⚐]</span></a></li>
			</ul>
			<ul>
				<li><span><span>2 Mathematical concepts</span></span><a href="#sec-2"><span>[⚐]</span></a></li>
				<ul>
					<li><span><span>2.1 Propositional expressions</span></span><a href="#sec-2.1"><span>[⚐]</span></a></li>
				</ul>
				<ul>
					<li><span><span>2.2 Conditional expressions</span></span><a href="#sec-2.2"><span>[⚐]</span></a></li>
				</ul>
				<ul>
					<li><span><span>2.3 Recursive function definitions</span></span><a href="#sec-2.3"><span>[⚐]</span></a></li>
				</ul>
				<ul>
					<li><span><span>2.4 Lambda calculus</span></span><a href="#sec-2.4"><span>[⚐]</span></a></li>
				</ul>
			</ul>
			<ul>
				<li><span><span>3 S-expressions and data structures</span></span><a href="#sec-3"><span>[⚐]</span></a></li>
				<ul>
					<li><span><span>3.1 S-expressions</span></span><a href="#sec-3.1"><span>[⚐]</span></a></li>
				</ul>
				<ul>
					<li><span><span>3.2 Atoms</span></span><a href="#sec-3.2"><span>[⚐]</span></a></li>
				</ul>
				<ul>
					<li><span><span>3.3 Lists</span></span><a href="#sec-3.3"><span>[⚐]</span></a></li>
					<ul>
						<li><span><span>3.3.1 Pairs</span></span><a href="#sec-3.3.1"><span>[⚐]</span></a></li>
					</ul>
					<ul>
						<li><span><span>3.3.2 Singly linked lists</span></span><a href="#sec-3.3.2"><span>[⚐]</span></a></li>
					</ul>
					<ul>
						<li><span><span>3.3.3 Trees</span></span><a href="#sec-3.3.3"><span>[⚐]</span></a></li>
					</ul>
				</ul>
			</ul>
			<ul>
				<li><span><span>4 Functions</span></span><a href="#sec-4"><span>[⚐]</span></a></li>
				<ul>
					<li><span><span>4.1 Introduction to functions</span></span><a href="#sec-4.1"><span>[⚐]</span></a></li>
				</ul>
				<ul>
					<li><span><span>4.2 Elementary functions</span></span><a href="#sec-4.2"><span>[⚐]</span></a></li>
				</ul>
				<ul>
					<li><span><span>4.3 Defining functions</span></span><a href="#sec-4.3"><span>[⚐]</span></a></li>
				</ul>
				<ul>
					<li><span><span>4.4 Creating new functions</span></span><a href="#sec-4.4"><span>[⚐]</span></a></li>
				</ul>
			</ul>
			<ul>
				<li><span><span>5 Memory management</span></span><a href="#sec-5"><span>[⚐]</span></a></li>
				<ul>
					<li><span><span>5.1 Representation of s-expressions by list structures</span></span><a href="#sec-5.1"><span>[⚐]</span></a></li>
				</ul>
				<ul>
					<li><span><span>5.2 Association lists</span></span><a href="#sec-5.2"><span>[⚐]</span></a></li>
				</ul>
				<ul>
					<li><span><span>5.3 Garbage collection</span></span><a href="#sec-5.3"><span>[⚐]</span></a></li>
				</ul>
				<ul>
					<li><span><span>5.4 Other concepts</span></span><a href="#sec-5.4"><span>[⚐]</span></a></li>
				</ul>
			</ul>
			<ul>
				<li><span><span>6 Conclusion</span></span><a href="#sec-6"><span>[⚐]</span></a></li>
			</ul>
			<ul>
				<li><span><span>7 References</span></span><a href="#sec-7"><span>[⚐]</span></a></li>
			</ul>
			<ul>
				<li><span><span>8 Appendix</span></span><a href="#sec-8"><span>[⚐]</span></a></li>
			</ul>
		</div>
		<div class="sec" id="sec-1">
			<h1>1 Introduction</h1>
			<p>The paper (<a id="bib-LISP" href="#id-LISP">[LISP]</a>) describes a dynamic typed and functional programming language called LISP. The name LISP is an abbreviation for <span class="bold">LIS</span>t <span class="bold">P</span>rocessor, which is a very suitable name, because the whole syntax is completely based on a simple list notation for code and data.</p>
			<p>LISP was developed in 1958, two years before the paper was published. The main purpose for the development was the lack of appropriate programming languages for artificial intelligence applications. At this time FORTRAN was the dominant high level programming language, but it was developed for numeric calculations and engineering tasks and therefore no good fit for AI problems.</p>
			<p>LISP was influenced by IPL (Information Processing Language), which was an experimental programming language from 1957 (see <a id="bib-IPL" href="#id-IPL">[IPL]</a>). IPL was dedicated to AI research, but also inappropriate because it was an assembly language. Some of the IPL concepts that LISP had adopted and heavily improved were: list-processing, higher-order functions, recursion and computation with symbols. Some other concepts were new, for example: conditional control flow, garbage collection, lazy evaluation, and dynamic typing.</p>
			<p>At first, we will learn something about the mathematical concepts behind LISP. Then, we will see that the early LISP had only two simple data types. After that, we will define 5-7 elementary functions and we will use them as building blocks to create our own functions. Then, we will see how the memory management works. At the end, we will look, how LISP was doing in the past 55 years and how LISP is doing today.</p>
		</div>
		<div class="sec" id="sec-2">
			<h1>2 Mathematical concepts</h1>
			<div class="sec" id="sec-2.1">
				<h2>2.1 Propositional expressions</h2>
				<p>Propositional expressions are expressions whose values are either <span class="code">T</span> "true" or <span class="code">F</span> "false". These expressions are often combined by connectives like <span class="code">∧</span> "and", <span class="code">∨</span> "or" and <span class="code">¬</span> "not". Typical examples are:</p>
				<div class="math">$$x &lt; y$$
$$(x &lt; y) \land (b = c)$$</div>
			</div>
			<div class="sec" id="sec-2.2">
				<h2>2.2 Conditional expressions</h2>
				<p>The notation of conditional expressions was a new concept, developed by McCarthy in 1960. It is the ancestor of the "if...then...else" condition, who is part of nearly every programming language nowadays. Conditional expressions allow a recursive definition of functions in a convenient way. A conditional expression has the form:</p>
				<div class="math">$$(p_1 \rightarrow e_1,\cdots,p_n \rightarrow e_n)$$</div>
				<p>The <span class="bold">p</span>’s are propositional expressions that are true or false. The <span class="bold">e</span>’s could be any kind of expression. One could read "if <span class="bold">p</span><span class="sub">1</span> then <span class="bold">e</span><span class="sub">1</span>, else if <span class="bold">p</span><span class="sub">2</span> then <span class="bold">e</span><span class="sub">2</span>, ..., else if <span class="bold">p</span><span class="sub">n</span> then <span class="bold">e</span><span class="sub">n</span>" or "<span class="bold">p</span><span class="sub">1</span> yields <span class="bold">e</span><span class="sub">1</span>, ..., <span class="bold">p</span><span class="sub">n</span> yields <span class="bold">e</span><span class="sub">n</span>".</p>
				<p>The <span class="bold">p</span>’s get evaluate from left to right. When the first true <span class="bold">p</span> is found, then the conditional expressions returns the <span class="bold">e</span> that belongs to the <span class="bold">p</span>.</p>
				<div class="math">$$(1 &lt; 2 \rightarrow 4, 1 > 2 \rightarrow 3) = 4$$

$$(2 &lt; 1 \rightarrow 4, 2 > 1 \rightarrow 3, 2 > 1 \rightarrow 2) = 3$$

$$(2 &lt; 1 \rightarrow 4, T \rightarrow 3) = 3$$

$$(2 &lt; 1 \rightarrow {0 \over 0}, T \rightarrow 3) = 3$$</div>
				<p>The whole conditional expressions is undefined:</p>
				<ol>
					<li>if all <span class="bold">p</span>'s are false, </li>
					<li>if an undefined <span class="bold">p</span> occurs before a true <span class="bold">p</span> occurs </li>
					<li>or if the <span class="bold">e</span> that belongs to the first true <span class="bold">p</span> is undefined it self</li>
				</ol>
				<div class="math">$$(2 &lt; 1 \rightarrow 3, 4 &lt; 1 \rightarrow 4) \mbox{ is undefined}$$

$$({0 \over 0} &lt; 1 \rightarrow 3, 1 &lt; 4 \rightarrow 4) \mbox{ is undefined}$$

$$(2 &lt; 1 \rightarrow 3, T \rightarrow {0 \over 0} )\mbox{ is undefined}$$</div>
			</div>
			<div class="sec" id="sec-2.3">
				<h2>2.3 Recursive function definitions</h2>
				<p>With the help of conditional expressions it is easy to define recursive functions. The factorial of a non-negative integer <span class="bold">n</span> could be described as follows:</p>
				<div class="math">$$n! = (n = 0 \rightarrow 1, T \rightarrow n \cdot(n - 1)!)$$</div>
				<p>The evaluation of 0! returns 1. The evaluation of 2! looks as follows:</p>
				<div class="math">\begin{eqnarray*}
2! &amp;=&amp; (2 = 0 \rightarrow 1, T \rightarrow 2 \cdot (2 - 1)!)\\
&amp;=&amp; 2 \cdot 1!\\
&amp;=&amp; 2 \cdot (1 = 0 \rightarrow 1 T \rightarrow \cdot (1 - 1)!)\\
&amp;=&amp; 2 \cdot 1 \cdot 0!\\
&amp;=&amp; 2 \cdot 1 \cdot (0 = 0 \rightarrow 1, T \rightarrow 0\cdot(0-1)!)\\
&amp;=&amp;2\cdot1\cdot1\\
&amp;=&amp;2
\end{eqnarray*}</div>
			</div>
			<div class="sec" id="sec-2.4">
				<h2>2.4 Lambda calculus</h2>
				<p>The Lambda calculus is a formal notation, which is used in LISP to generate new functions and to use functions as arguments. It was introduced by Alonzo Church in 1941 (see <a id="bib-LAMBDA" href="#id-LAMBDA">[LAMBDA]</a>).</p>
				<p>Church distinguishes between forms and functions. An expression like <span class="math">$y^2 + x$</span> is a form. An expression like <span class="math">$f(3, 4)$ </span> a function. <span class="math">$y^2 + x$</span> is not a function because the expression <span class="math">$y^2 + x(3, 4)$</span> does not determine and could turn into 19 or 13. The problem is that the order, in which the arguments 3 and 4 are inserted into the form, is undefined. To convert a form into a function we can write: is $2.50 for the first one, and $2.00 for each additional one</p>
				<div class="math">$$\lambda((x_1, \cdots, x_n),\cal E)$$</div>
				<p><span class="math">$\cal E$</span> is a form and <span class="math">$x_1, \cdots, x_n$</span> are the ordered parameters for <span class="math">$\cal E$</span>. The λ-expression is a function because the variables in <span class="math">$\cal E$</span> can be substituted with arguments in the order of the parameter list <span class="math">$x_1, \cdots, x_n$</span>. We say that the variables of a λ-expression are bounded. The example from above looks now like this:</p>
				<div class="math">$$\lambda((x,y),y^2 +x)$$</div>
				<p>And with arguments like this:</p>
				<div class="math">$$\lambda((x,y),y^2 +x)(3,4) = 19$$</div>
				<p>If we want to define a recursive function like</p>
				<div class="math">$${\rm sqrt}(a,x,\epsilon)
        = (|x^2 - a| &lt; \epsilon \rightarrow x, T \rightarrow {\rm sqrt}(a,
{1 \over 2}(x + {a \over x}),\epsilon))$$</div>
				<p>in lambda notation</p>
				<div class="math">$${\rm sqrt} = \lambda((a,x,\epsilon),(|x^2 - a| &lt; \epsilon \rightarrow x,
T\rightarrow
{\rm sqrt} (a,{1 \over 2}(x + {a \over x}), \epsilon))),$$</div>
				<p>we found that these definition is inadequate, because the right-hand side <span class="math">$sqrt$</span> can not serve as an expression for the whole function. Remember, a function would look like <span class="math">$sqrt(a,x,ε)$</span>.</p>
				<p>In order to define recursive λ-expressions, we must introduce a new notation.</p>
				<div class="math">$$label(f,\cal E)$$</div>
				<p><span class="bold">f</span> can be seen as the function name. The occurrence of <span class="bold">f</span> within <span class="math">$\cal E$</span> will be evaluated to the label-expression as if <span class="bold">f</span> is a parameter of the function. </p>
				<div class="math">$$label(sqrt, \lambda((a,x,\epsilon),(| x^2 - a|
&lt; \epsilon \rightarrow x, T \rightarrow {\rm sqrt} (a, {1 \over 2}(x + {a
\over x}),\epsilon))))$$</div>
			</div>
		</div>
		<div class="sec" id="sec-3">
			<h1>3 S-expressions and data structures</h1>
			<div class="sec" id="sec-3.1">
				<h2>3.1 S-expressions</h2>
				<p>The whole syntax of LISP is made of symbolic-expressions or shorter s-expressions. All code and data can be expressed by the following syntax elements. </p>
				<p>S-expressions are formed by these characters: <span class="code">(</span>, <span class="code">)</span>, <span class="code">.</span>, and an infinite set of distinguishable atoms. The only data types in this early version of LISP are atoms and lists.</p>
			</div>
			<div class="sec" id="sec-3.2">
				<h2>3.2 Atoms</h2>
				<p>Atoms are numbers or strings of characters. These strings are often symbols and represent an other atom or list. If LISP code gets interpreted or compiled,  symbols get replaced with their referenced data items.</p>
				<pre><code class="lisp">1
12

a
ab
aaaaabb

t
nil</code></pre>
			</div>
			<div class="sec" id="sec-3.3">
				<h2>3.3 Lists</h2>
				<div class="sec" id="sec-3.3.1">
					<h3>3.3.1 Pairs</h3>
					<p>Pairs are also called cons cells or cons. They are expressed in this form:</p>
					<pre><code class="lisp">(1 . 2)
(a . b)</code></pre>
					<p>A pair has two pointers to values. The first pointer is called <span class="code">car</span> and the second pointer is called <span class="code">cdr</span>. We will see later why this is relevant.</p>
					<img src="images/pair.svg">
					<div class="cap"><span>Fig 3.1: </span>Memory representation of two pairs</div>
				</div>
				<div class="sec" id="sec-3.3.2">
					<h3>3.3.2 Singly linked lists</h3>
					<p>Pairs can be used to build more complex data structures like singly linked lists.</p>
					<pre><code class="lisp">(1 . (2 . (3 . nil)))</code></pre>
					<img src="images/list.svg">
					<div class="cap"><span>Fig 3.2: </span>Memory representation of a list</div>
					<p>We can see that the <span class="code">car</span> pointer points to the first element of a pair and that the <span class="code">cdr</span> pointer points to the second element, which is the rest of the list structure. Like <span class="code">(1 . rest)</span>, but the <span class="code">rest</span> is the sublist <span class="code">(2 . (3 . nil))</span>. The sublist <span class="code">(2 . (3 . nil))</span> is also a pair of <span class="code">(2 . rest)</span>, where the <span class="code">rest</span> is <span class="code">(3 . nil)</span>. The list notation can be abbreviated.</p>
					<pre><code class="lisp">(1 2 3)</code></pre>
					<p>Through the missing <span class="code">.</span> dot pairs and lists are distinguishable. Now we give some examples of lists in their abbreviated and their dotted-pair notation.</p>
					<pre><code class="lisp">(1)
(1 . nil)

(a b)
(a . (b . nil))

(1 2 (3 4))
(1 . (2 . ((3 . (4 . nil)))))

(1 2 . 3)
(1 . (2 . 3))

((a b) c)
((a . (b . nil)) . (c . nil)))</code></pre>
				</div>
				<div class="sec" id="sec-3.3.3">
					<h3>3.3.3 Trees</h3>
					<p>Some data structures can also be seen as binary trees.</p>
					<pre><code class="lisp">((1 . 2) . (3 . 4))</code></pre>
					<img src="images/tree.svg">
					<div class="cap"><span>Fig 3.3: </span>Memory representation of a tree</div>
				</div>
			</div>
		</div>
		<div class="sec" id="sec-4">
			<h1>4 Functions</h1>
			<div class="sec" id="sec-4.1">
				<h2>4.1 Introduction to functions</h2>
				<p>In the original paper McCarthy didn't used s-expressions to describe LISP functions, but m-expressions, which stands for meta-expressions. M-expressions are very similar to the standard notation of functions. They take s-expressions as data and to avoid ambiguity they have brackets instead of parenthesis. A m-expression function could look like this:</p>
				<div class="math">$$function[(A \cdot B); x]$$ </div>
				<p>M-expressions, which describes LISP functions, are called s-functions. However, to use these s-functions for computation, they had to get converted into pure s-expressions. Because the converted s-functions are much better readable in their s-expression notation, and because the additional level of indirection is unnecessary, m-expressions were almost never used for real LISP programming.</p>
				<p>For this reason all examples from the McCarty paper had been converted into runnable LISP code. Common Lisp was the best choice for this purpose, because it implements, in contrast to Scheme or Clojure, all functions we will take a closer look at in a moment.</p>
				<p>Now we give a very short introduction to the usage of functions. This is not part of the McCarthy paper, but helpful to follow the Common Lisp examples.</p>
				<p>LISP functions are also lists and looking as follows:</p>
				<pre><code class="clojure">(operator arg1 arg2 ... argn)</code></pre>
				<p>Some simple examples are given with arithmetic operators:</p>
				<pre><code class="clojure">> (+ 1 2)
3

> (* 2 (- 6 3))
6</code></pre>
				<p>Operators gets applied from left to right. <span class="code">(+ 1 2 3 4 5)</span> is equal to <span class="code">1 + 2 + 4 + 5</span>. Nested expressions get evaluated at first. <span class="code">(+ (* 3 1) (* 2 3))</span> is equal to <span class="code">(+ 3 6)</span>. This notation for arithmetic operations is also known as Polish notation and was invented by Jan Łukasiewicz in 1928 (see <a href="http://en.wikipedia.org/wiki/Polish_notation">Wikipedia</a>).</p>
				<p>To distinguish data from function calls we use a single quote <span class="code">'</span> to mark expressions as data. This prevents them from getting evaluated. The <span class="code">'</span> is an abbreviation for <span class="code">(quote x)</span>. <span class="code">x</span> can be every expression.</p>
				<pre><code class="lisp">> (1 2)
Error ;; Because 1 is not a function name

> '(1 2)
(1 2)
> (quote (1 2))
(1 2)

> s
Error ;; Because s is undefined
> 's ;; Undefined symbols must be quoted
s
> (defparameter s 7) ;; Defines variable s
> s
7</code></pre>
			</div>
			<div class="sec" id="sec-4.2">
				<h2>4.2 Elementary functions</h2>
				<p>McCarthy defines in his Paper 5 elementary functions: <span class="code">atom</span>, <span class="code">eq</span>, <span class="code">car</span>, <span class="code">cdr</span>, and <span class="code">cons</span>. This functions are implemented as assembly code and can not become substituted by other expressions. We will see later, how we can use these functions to build new functions with them.</p>
				<h1>atom</h1>
				<p><span class="code">(atom x)</span> returns <span class="code">t</span> "true" if <span class="code">x</span> is an atom. Otherwise it returns <span class="code">nil</span>. <span class="code">nil</span> represents falsity and is equal to the empty list <span class="code">()</span>.</p>
				<pre><code class="lisp">> (atom 1)
t

> (atom  '(1 2))
nil

> (atom ())
t</code></pre>
				<h1>eq</h1>
				<p><span class="code">(eq x y)</span> returns <span class="code">t</span> if <span class="code">x</span> and <span class="code">y</span> are the same atom. Otherwise it returns <span class="code">nil</span>.</p>
				<pre><code class="lisp">> (eq 1 4)
nil

> (eq 'a 'a)
t

> (eq nil ())
t</code></pre>
				<h1>car</h1>
				<p><span class="code">(car x)</span> expects that <span class="code">x</span> is not an atom, but a list. It returns the first element of <span class="code">x</span>. <span class="code">car</span> stand for "<span class="bold">c</span>ontents of the <span class="bold">a</span>ddress part of <span class="bold">r</span>egister". We have seen in section <a href="#sec-3.3.1">3.3.1 Pairs</a> that the first pointer is called <span class="code">car</span> too, because he points to the first element of the list.</p>
				<pre><code class="lisp">> (car '(1 . 2))
1

> (car '(a b c))
a</code></pre>
				<h1>cdr</h1>
				<p><span class="code">(cdr x)</span> expects also that <span class="code">x</span> is not an atom, but a list. It returns all elements after the first element of <span class="code">x</span>. <span class="code">cdr</span> is the abreviation of "<span class="bold">c</span>ontents of the <span class="bold">d</span>ecrement part of <span class="bold">r</span>egister". The <span class="code">cdr</span> pointer of a list points to everything after the <span class="code">car</span> pointer.</p>
				<pre><code class="lisp">> (cdr '(1 . 2))
2

> (cdr '(a b c))
(b c)

> (cdr '('(a b) c))
(c)</code></pre>
				<h1>cons</h1>
				<p><span class="code">(cons x y)</span> creates the new pair <span class="code">(x . y)</span> out of <span class="code">x</span> and <span class="code">y</span>. <span class="code">x</span> and <span class="code">y</span> can be atoms or lists. <span class="code">cons</span> stands for <span class="bold">cons</span>truct.</p>
				<pre><code class="lisp">> (cons 1 2)
(1 . 2)

> (cons 1 '(a b c))
(1 a b c)

> (cons '(1 2) '(a b))
((1 2) a b)

> (cons '(1 c) '(3 . 3))
((1 c) 3 . 3)</code></pre>
				<p>Some examples how <span class="code">car</span>, <span class="code">cdr</span> and <span class="code">cons</span> could interact:</p>
				<pre><code class="lisp">> (car (cons 1 'a))
1

> (cdr (cons '(1 2 3) '(a b c)))
(a b c)

> (cons (car '(1 2)) 
		(cdr '(a b c)))
(1 b c)</code></pre>
				<h1>cond</h1>
				<p><span class="code">cond</span> is not directly one of the 5 elementary functions from the paper. McCarthy has introduced it implicitly as an conversion rule from m-expressions to s-expressions. According to Paul Graham (see <a id="bib-ROOTS" href="#id-ROOTS">[ROOTS]</a>) <span class="code">cond</span> is so essential that it can be seen as a sixth elementary function.</p>
				<p><span class="code">(cond (p1 e1)...(pn en))</span> is used to control the program flow. It works like described in section <a href="#sec-2.2">2.2 Conditional expressions</a>.</p>
				<pre><code class="lisp">> (cond 
	((atom 'a) 1) ;; if 'a is an atom then return 1
	((eq 1 1)  2) ;; else if 1 is equal to 1 then return 2
	(t 0)) ;; else return 0
1</code></pre>
				<h1>quote</h1>
				<p>For <span class="code">quote</span> applies the same like for <span class="code">cond</span>. It was only introduced implicitly, but it is also this important that it can be seen as the seventh elementary function. We already know how <span class="code">quote</span> works, but for the sake of completeness:</p>
				<p><span class="code">(quote x)</span> takes every expression <span class="code">x</span> and prevent its evaluation. It can be abbreviate with <span class="code">'x</span>.</p>
				<pre><code class="lisp">> (quote (cons 1 1))
(cons 1 1)

> '(cons 1 1)
(cons 1 1)</code></pre>
			</div>
			<div class="sec" id="sec-4.3">
				<h2>4.3 Defining functions</h2>
				<p><span class="code">lambda</span> and <span class="code">label</span> provide a notation to define our own functions.</p>
				<p><span class="code">lambda</span> is used, like described in section <a href="#sec-2.4">2.4 Lambda calculus</a>, to bind arguments on an anonymous function.</p>
				<p>The s-expression of the lambda calculus looks like this: <span class="code">(lambda (p1...pn) e)</span> and a function call with arguments has this form: <span class="code">((lambda (p1...pn) e) a1...an)</span>.</p>
				<pre><code class="lisp">> ((lambda (x y) (cons x y)) 1 2)
(1 . 2)</code></pre>
				<p>For function calls of <span class="code">lambda</span> we need, like in section <a href="#sec-2.4">2.4 Lambda calculus</a>, the <span class="code">label</span> notation <span class="code">(label f (lambda (p1...pn) e))</span>.</p>
				<p>Since <span class="code">label</span> is unavailable in Common Lisp, we give no code example and just abbreviate <span class="code">(label f (lambda (p1...pn) e))</span> to <span class="code">(defun f (p1...pn) e)</span>. <span class="code">defun</span> is a Common Lisp macro that defines a function that uses these form:</p>
				<pre><code class="lisp">(defun &lt;function-name> (&lt;parameter1>&lt;parameter2>...&lt;parameterN>) 
  &lt;function-body>)</code></pre>
				<p>Now we have the power to create all computable functions!</p>
			</div>
			<div class="sec" id="sec-4.4">
				<h2>4.4 Creating new functions</h2>
				<p>McCarthy gives in his paper some examples of new functions like <span class="code">ff</span>, <span class="code">subset</span>, <span class="code">equal</span>, <span class="code">null</span>, <span class="code">cadr</span>, <span class="code">caddr</span>, <span class="code">list</span>, <span class="code">among</span>, <span class="code">pair</span>, <span class="code">assoc</span>, <span class="code">sublis</span>, <span class="code">sub2</span>, <span class="code">apply</span>, <span class="code">appq</span>, <span class="code">eval</span>, <span class="code">maplist</span>, and <span class="code">search</span>. </p>
				<p>With his small examples, he prepares the bigger <span class="code">eval</span>/<span class="code">apply</span> example. He proves with this functions that he can build a complete LISP interpreter out of the elementary functions in a few lines of code (see Paul Graham's Common Lisp version of it <a href="#id-EVAL">Listing 8.1</a>). </p>
				<p>We will pick some interesting smaller examples, to show the capabilities of this early version of LISP.</p>
				<h1>Logical connectives</h1>
				<p>With the help of <span class="code">cond</span> it is easy to build <span class="code">(not p)</span>, <span class="code">(and p q)</span> and <span class="code">(or p q)</span>. <span class="code">p</span> and <span class="code">q</span> can be every expression. <span class="code">not</span>, <span class="code">and</span>, and <span class="code">or</span> will return <span class="code">t</span> or <span class="code">nil</span>.</p>
				<pre><code class="lisp">> (defun not (p)
	(cond
		(p nil)
		(t t)))

> (not t)
nil

> (defun and (p q)
	(cond
		(p (cond (q t) (t nil)))
		(t nil)))

> (and t t)
t

> (defun or (p q)
	(cond
		(p t)
		(t (cond (q t) (t nil)))))

> (or nil t)
t</code></pre>
				<h1>Recursive functions</h1>
				<p><span class="code">(append x y)</span> takes two lists and returns them concatenated.</p>
				<pre><code class="lisp">> (defun null (x)
	(eq x nil))

> (defun append (x y)
	(cond 
		((null x) y)
		(t (cons (car x) (append (cdr x) y)))))

> (append '(1 1) '(a a))
(1 1 a a)</code></pre>
				<p><span class="code">append</span> consists of two conditional clauses. The first condition <span class="code">((null x) y)</span> is the termination condition and returns <span class="code">y</span> if <span class="code">x</span> is <span class="code">nil</span>. The second condition <span class="code">(t (cons (car x) (append (cdr x) y)))</span> gets always called, except <span class="code">x</span> is <span class="code">nil</span> and does a couple of things:</p>
				<ol>
					<li>it <span class="code">cons</span>tructs a new list from the <span class="code">car</span> of <span class="code">x</span> and the result of <span class="code">(append (cdr x) y)</span></li>
					<li>it calls <span class="code">(append (cdr x) y)</span> recursively and builds a stack with the <span class="code">cdr</span>'s of <span class="code">x</span> until <span class="code">(cdr x)</span> returns <span class="code">nil</span></li>
					<li>if <span class="code">(cdr x)</span> returns <span class="code">nil</span>, a list from the last element of <span class="code">x</span> and <span class="code">y</span> will be <span class="code">cons</span>structed</li>
				</ol>
				<p>Now we show a part of the stack for <span class="code">(append '(1 2 3) '(6 6))</span> to illustrate how the recursion works in detail:</p>
				<pre><code class="lisp">(append '(1 2 3) '(6 6))
(cons 1 (append '(2 3) '(6 6)))
(cons 1 (cons 2 (append 3 '(6 6))))
(cons 1 (cons 2 (cons 3 (append nil '(6 6))))) ;; x is nil
(cons 1 (cons 2 (cons 3 '(6 6))))
(cons 1 (cons 2 '(3 6 6)))
(cons 1 '(2 3 6 6))
'(1 2 3 6 6)</code></pre>
				<p>At the point where <span class="code">x</span> is <span class="code">nil</span>, the termination condition <span class="code">((null nil) '(6 6))</span> gets invoked, and the last call of <span class="code">append</span> returns <span class="code">'(6 6)</span>. Then the stack gets reduced to the resulting list <span class="code">'(1 2 3 6 6)</span>.</p>
				<h1>Higher-order functions</h1>
				<p>Higher-order functions are functions that take other functions as arguments, or functions that return functions.</p>
				<p><span class="code">(maplist f x)</span> takes the function <span class="code">f</span> and the list <span class="code">x</span> as arguments, and applies <span class="code">f</span> on every element in <span class="code">x</span>.</p>
				<p>For this example McCarthy introduces arithmetic operators like <span class="code">(+ a1...an)</span>, and <span class="code">(* a1...an)</span>, but he didn't give any further explanations how they are realized internally. </p>
				<pre><code class="lisp">;; In Common Lisp
> (defun maplist (f x)
	(cond 
		((null x) nil)
		(t (cons (funcall f (car x)) (maplist f (cdr x))))))
		
> (defun double (x) (* x 2))

> (maplist #'double '(5 6))
(10 12)

;; "funcall f" and "#'double" are "special" CL syntax 
;; and theoretically unnecessary. 
;; The syntax of Scheme is much cleaner:

;; In Scheme
> (define (maplist f x)
	(cond
		((null? x) null)
		(#t (cons (f (car x)) (maplist f (cdr x))))))

> (define (double x) (* 2 x))

> (maplist double '(5 6))
(10 12)</code></pre>
			</div>
		</div>
		<div class="sec" id="sec-5">
			<h1>5 Memory management</h1>
			<div class="sec" id="sec-5.1">
				<h2>5.1 Representation of s-expressions by list structures</h2>
				<p>We have already seen in section <a href="#sec-3.3">3.3 Lists</a> how simple s-expressions are represented in the memory. Now we will see how more complex s-expressions can be stored. The subdivided rectangle represents a register that stores two pointers. This notation was introduce by Allen Newell and J.C. Shaw in 1957 (see <a id="bib-IPL" href="#id-IPL">[IPL]</a>).</p>
				<p>Substructures can occur in more than one place. The lists <span class="code">(1 3)</span> and <span class="code">(2 3)</span> share the pair <span class="code">(3 . nil)</span>. This has the advantage that subexpressions that occurs in more than one place must only stored once.</p>
				<img src="images/share.svg">
				<p>In some cases it is possible that a subexpression that occurs more than once is represented in more than one way. This is dependent on the history of the program. The list <span class="code">((1 . 2) . (1 . 2))</span> could be an example.</p>
				<img src="images/history.svg">
				<p>Cycles in list structures are forbidden.</p>
				<img src="images/circle.svg">
			</div>
			<div class="sec" id="sec-5.2">
				<h2>5.2 Association lists</h2>
				<p>Association lists, also known as property lists, are lists of a special form to represent symbols. The first <span class="code">car</span> field contains a special constant to tell the system that it deals with a symbol. The association list can contain further informations about the symbol like:</p>
				<ul>
					<li>the print name</li>
					<li>a numerical value if the symbol represents a number</li>
					<li>another s-expression if the symbol serves as a name for it</li>
					<li>the location of a routine if the symbol represents a function</li>
				</ul>
				<p>McCarthy describes in his paper only how print names are represented by association lists. The association list of the symbol <span class="code">differentiate</span> has a substructure of these form:</p>
				<img src="images/pname.svg">
				<p>Since LISP was developed on an IBM 704, which had a 36-bit architecture, the words in this example consists of six 6 bit characters.</p>
			</div>
			<div class="sec" id="sec-5.3">
				<h2>5.3 Garbage collection</h2>
				<p>Garbage collection is one of the most important concepts that were introduced within the paper. It is a form of automatic memory management and is used to free the memory from unnecessary list structures without any action of the programmer.</p>
				<img src="images/gc.svg">
				<div class="cap"><span>Fig 5.1: </span>The pairs <span class="code">(c . nil)</span> and <span class="code">(4 . 8)</span> are garbage.</div>
				<p>A so called free-storage list is used to catalogue the available free memory. The free-storage list starts with a register called <span class="code">free</span> and holds a pointer to the first free register in the list. If the program requires a register for a new list structure, the first register of the free-storage list is taken, and the <span class="code">free</span> pointer gets attached to the second register of the free-storage list. This mechanism is know today as dynamic memory allocation.</p>
				<p>To decide which registers are still in use and which are abandoned, the base register holds pointers to all accessible list structures. If a list structure is not accessible by a chain of <span class="code">car</span> and <span class="code">cdr</span> operations it is garbage.</p>
				<p>To free the memory from the unaccessible lists a mark-and-sweep algorithm is used. In the first phase of mark-and-sweep all accessible registers get marked. In the second phase all unmarked registers get appended to the end of the free-storage list and are reusable after that. In the third phase all marked registers get unmarked.</p>
				<p>The garbage collection mechanism gets only activated if the program runs out of free storage. </p>
			</div>
			<div class="sec" id="sec-5.4">
				<h2>5.4 Other concepts</h2>
				<p>McCarthy also describes a strategy for lazy evaluation of conditional expressions. Only the p’s and e’s that are required get computed.</p>
				<p>He also introduces the stack as a new concept. Through the use of stacks recursion is possible. The problem of recursion without a stack is that the program needs the same registers, that are also used by the previous level of recursion, to store the actual recursion result. This conflict is resolved by pushing and popping the results on a stack to store them temporary.</p>
			</div>
		</div>
		<div class="sec" id="sec-6">
			<h1>6 Conclusion</h1>
			<p>Before we evaluate the quality of LISP as a programming language, we are going to outline the development of LISP until today. After 1958, LISP became successful as AI language. Countless new LISP dialects were developed by universities and companies. Because LISP had efficiency issues the creation of special hardware, so called Lisp machines, was necessary. During the 1970, 1980s, and the early 1990s LISP had a very good period with a lot of funding from the US government, the US military, and the industry. LISP programming was a standard topic at some universities. </p>
			<p>In 1975, <span class="bold">Scheme</span>, one of the 3 major dialects that are still relevant today, was developed from Guy L. Steele and Gerald Jay Sussman at the MIT. The main characteristics of Scheme are: a very minimalistic syntax and core library, lexical scoping, and tail-call optimization. </p>
			<p>In 1984, <span class="bold">Common Lisp</span>, the second of the 3 dialects, was developed to standardize some earlier LISPs. Common Lisp is characterized by an inconsistent syntax, an huge number of libraries, and an extension for object oriented programming. </p>
			<p>In the mid-1990s the funding and the interest in AI research had dropped because of disappointment about the unsatisfying results in the AI field. During the "AI Winter" the popularity of LISP had decreased dramatically. </p>
			<p>LISP had a small "comeback" in the 2000s where a couple of new LISPs were developed. One of them was the third important dialect <span class="bold">Clojure</span>, which was developed from Rich Hickey in 2007. Clojure is built upon the JVM and supports some new features like multithreading and immutable data types.</p>
			<p>The most concepts from the McCarthy paper are still core concepts of recent LISPs. Over the years, LISP had also gained some new functionality and is today a multi-paradigm and general-purpose programming language. The DNA of almost every LISP can be described as:</p>
			<ul>
				<li>LISP is <span class="bold">functional</span>, it supports higher-order functions, lambda functions and closures</li>
				<li>It is <span class="bold">dynamic</span>, because of its dynamic type system and because it runs usually in an interactive programming environment called <span class="bold">REPL</span> (Read-Evaluate-Print-Loop)  </li>
				<li>It has <span class="bold">automatic memory management</span>, because it uses garbage collection and automatic memory allocation</li>
				<li>It supports meta programming with a very powerful <span class="bold">macro system</span></li>
				<li>it is <span class="bold">homoiconic</span>, that means code and data have the same list syntax</li>
				<li><span class="bold">Lists</span> are the major data structure</li>
				<li><span class="bold">Recursion</span> is the most common way to express iteration</li>
			</ul>
			<div class="quote">
				<p>It seems to me that there have been two really clean models of programming so far the C model and the Lisp model.</p>
				<div class="source">Paul Graham</div>
			</div>
			<p>LISP is in many ways different than other programming languages. On the one hand, it has these extreme minimalistic syntax, on the other hand, it has nearly endless expressive power. This means that LISP code can get created or changed directly through other LISP code. These expressiveness is accomplished by the homoiconicity and macros. The most famous example is the CLOS (Common Lisp Object System), which is a language extensions that makes object oriented programming under Common Lisp possible. An other example are DSLs (Domain Specific Languages), which are easy writable in LISP. Basically, LISP is able to adapt every functionality and every paradigm without changing the compiler or interpreter. For example, Clojure supports logic programming (see <a href="https://github.com/clojure/core.logic">core.logic on Github</a>) and pattern matching (see <a href="https://github.com/clojure/core.match">core.match on Github</a>) since 2011.</p>
			<div class="quote">
				<p>Lisp isn't a language, it's a building material.</p>
				<div class="source">Alan Kay</div>
			</div>
			<p>Probably LISP was a few decades ahead of other programming languages. It influenced almost every programming language that followed later like Python, Ruby, or JavaScript. Some languages still came up with features that LISP already had 39 years ago. For example, Objective-C introduced blocks, also known as closures, in 2009 (see <a href="http://arstechnica.com/apple/2009/08/mac-os-x-10-6/10/">arstechnica.com</a>). A closure like concept called lambda expressions is also planed for Java 8 (see <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Oracle</a>).</p>
			<p>But LISP is not as successful as one could expect from a language with all that superior functionality. If we compare the amount of LISP related questions with the amount of questions to other programming languages on <a href="http://stackoverflow.com">stackoverflow.com</a>, we found that LISP is not very popular. The percentage of questions about the three major LISP dialects is approximately on the same low level under 0.3%.</p>
			<img src="images/lisps.svg">
			<div class="cap" id="id-DIALECTS"><span>Fig. 6.1: </span>Popularity of LISP dialects on <a href="http://stackoverflow.com">stackoverflow.com</a> (see <a href="http://hewgill.com/~greg/stackoverflow/stack_overflow/tags/#!clojure+lisp+common-lisp+scheme">source</a>)</div>
			<p>How low this is becomes more obvious when we compare LISP with some mainstream languages.</p>
			<img src="images/languages.svg">
			<div class="cap" id="id-LANGAGES"><span>Fig. 6.2: </span>Popularity of LISP and other programming languages on <a href="http://stackoverflow.com">stackoverflow.com</a> (see <a href="http://hewgill.com/~greg/stackoverflow/stack_overflow/tags/#!java+javascript+python+objective-c+lisp">source</a>)</div>
			<p>And even if we consider that functional programming languages are less frequently used than imperative programming languages, we must admit that it is rather unpopular.</p>
			<img src="images/functional.svg">
			<div class="cap" id="id-FUNCTIONS"><span>Fig. 6.3: </span>Popularity of LISP and other functional programming languages on <a href="http://stackoverflow.com">stackoverflow.com</a> (see <a href="http://hewgill.com/~greg/stackoverflow/stack_overflow/tags/#!scala+haskell+erlang+lisp">source</a>)</div>
			<p>Now we are going to discuss briefly some of the possible reasons for this situation.</p>
			<h1>Fragmentation of the ecosystem</h1>
			<p>The already small LISP community is not only divided into 3 main dialects, the dialects itself are also divided into many different implementations and flavors. Some examples are:</p>
			<p><span class="bold">Scheme derivatives:</span> <a href="http://racket-lang.org">Racket</a>, <a href="http://www.call-cc.org">CHICKEN</a>, <a href="http://www.paulgraham.com/arc.html">Arc</a>, <a href="http://gambitscheme.org/wiki/index.php/Main_Page">Gambit</a><br><span class="bold">Common Lisp derivatives:</span> <a href="http://www.franz.com/products/allegro-common-lisp">Allegro Common Lisp</a>, <a href="http://www.lispworks.com/products/lispworks.html">LispWorks</a>, <a href="http://www.clisp.org">CLISP</a>, <a href="http://ccl.clozure.com">Clozure CL</a></p>
			<p>The fragmentation is a huge problem, because there is no joint effort to improve the dialects or LISP as a whole.</p>
			<h1>Lack of successful applications</h1>
			<p>It appears as if <a href="https://news.ycombinator.com">Hacker News</a> is the only relevant LISP application nowadays. Hacker News is an minimalistic social news website, which ranks articles through a voting systems. Because of its simplicity it can not serve as a promotion for the capabilities of LISP, like Dropbox is a promotion for Python or Github is a promotion for Ruby. Therefore companies and developers see no economic or technical advantages in using LISP for their projects.</p>
			<h1>Lack of modern tools</h1>
			<p>The most commonly used development tools are often old and do not offer that comfort that modern tools for other languages do. Of course, <a href="http://www.gnu.org/software/emacs/">Emacs</a> is very sophisticated and offers every feature one could ever imagine, but it also  seems very unfamiliar to some people, and it needs a lot of effort to learn to use it effectively. A positive exception is <a href="http://www.lighttable.com">LightTable</a>, a modern IDE for Clojure.</p>
			<h1>Lack of jobs</h1>
			<p>There are worldwide almost no LISP programming jobs available. <a href="http://functionaljobs.com/jobs/search/?q=lisp">functionaljobs.com</a> lists at the moment 3 jobs and <a href="http://careers.stackoverflow.com/jobs?searchTerm=lisp">careers.stackoverflow.com</a> lists 4 jobs. So, job opportunities can not serve as a motivation to spend time for LISP development.</p>
			<h1>Large entry barriers</h1>
			<p>We have seen in <a href="#id-DIALECTS">Fig. 6.1</a> that none of the major LISP dialects and even Clojure are able to attract new developers. The LISP approach is so different compared with imperative and object oriented languages that some people may have problems with that paradigm shift. Some people also complain that LISP code is hard to read with all the parentheses and recursion. It appears also to be a problem for newbies to find guidance for choosing a dialect and tools. Like LISP it self, a lot of LISP related content in the internet is very old and looks therefore outdated or abandoned. Even if they are not outdated or abandoned, many web sites leave a very poor first impression, like <a href="http://www.lispworks.com/products/lispworks.html">LispWorks</a> and <a href="http://racket-lang.org">Racket</a>.</p>
			<p>However, LISP is still a beautiful programming language with an elegant syntax and endless expressiveness. This is even more impressive if one considers that it was developed 55 years ago.</p>
		</div>
		<div class="sec" id="sec-7">
			<h1>7 References</h1>
			<div class="bib" id="id-IPL">
				<a href="#bib-IPL">[IPL]↵</a>
				<p>Allen Newell and J. C. Shaw, Programming the logic theory machine, Los Angeles, 1957, <a href="http://www.textfiles.com/bitsavers/pdf/rand/ipl/P-954_Programming_The_Logic_Theory_Machine_Jan57.pdf">Source</a></p>
			</div>
			<div class="bib" id="id-LAMBDA">
				<a href="#bib-LAMBDA">[LAMBDA]↵</a>
				<p>Alonzo Church, The Calculi of Lambda-Conversion, Princeton University Press, Princeton, 1941</p>
			</div>
			<div class="bib" id="id-LISP">
				<a href="#bib-LISP">[LISP]↵</a>
				<p>John McCathy, Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I, Massachusetts Institute of Technology, Cambridge, Mass., 1960, <a href="http://www-formal.stanford.edu/jmc/recursive.html">Source</a></p>
			</div>
			<div class="bib" id="id-ROOTS">
				<a href="#bib-ROOTS">[ROOTS]↵</a>
				<p>Paul Graham, Roots of Lisp, 2002, <a href="http://ep.yimg.com/ty/cdn/paulgraham/jmc.ps">Source</a></p>
			</div>
		</div>
		<div class="sec" id="sec-8">
			<h1>8 Appendix</h1>
			<pre><code class="lisp">; The Lisp defined in McCarthy's 1960 paper, translated into CL.
; Assumes only quote, atom, eq, cons, car, cdr, cond.
; Bug reports to lispcode@paulgraham.com.

(defun null. (x)
  (eq x '()))

(defun and. (x y)
  (cond (x (cond (y 't) ('t '())))
        ('t '())))

(defun not. (x)
  (cond (x '())
        ('t 't)))

(defun append. (x y)
  (cond ((null. x) y)
        ('t (cons (car x) (append. (cdr x) y)))))

(defun list. (x y)
  (cons x (cons y '())))

(defun pair. (x y)
  (cond ((and. (null. x) (null. y)) '())
        ((and. (not. (atom x)) (not. (atom y)))
         (cons (list. (car x) (car y))
               (pair. (cdr x) (cdr y))))))

(defun assoc. (x y)
  (cond ((eq (caar y) x) (cadar y))
        ('t (assoc. x (cdr y)))))

(defun eval. (e a)
  (cond
    ((atom e) (assoc. e a))
    ((atom (car e))
     (cond
       ((eq (car e) 'quote) (cadr e))
       ((eq (car e) 'atom)  (atom   (eval. (cadr e) a)))
       ((eq (car e) 'eq)    (eq     (eval. (cadr e) a)
                                    (eval. (caddr e) a)))
       ((eq (car e) 'car)   (car    (eval. (cadr e) a)))
       ((eq (car e) 'cdr)   (cdr    (eval. (cadr e) a)))
       ((eq (car e) 'cons)  (cons   (eval. (cadr e) a)
                                    (eval. (caddr e) a)))
       ((eq (car e) 'cond)  (evcon. (cdr e) a))
       ('t (eval. (cons (assoc. (car e) a)
                        (cdr e))
                  a))))
    ((eq (caar e) 'label)
     (eval. (cons (caddar e) (cdr e))
            (cons (list. (cadar e) (car e)) a)))
    ((eq (caar e) 'lambda)
     (eval. (caddar e)
            (append. (pair. (cadar e) (evlis. (cdr e) a))
                     a)))))

(defun evcon. (c a)
  (cond ((eval. (caar c) a)
         (eval. (cadar c) a))
        ('t (evcon. (cdr c) a))))

(defun evlis. (m a)
  (cond ((null. m) '())
        ('t (cons (eval.  (car m) a)
                  (evlis. (cdr m) a)))))
</code></pre>
			<div class="cap" id="id-EVAL"><span>Listing 8.1: </span><span class="code">eval</span> by Paul Graham,  <a href="http://ep.yimg.com/ty/cdn/paulgraham/jmc.lisp">Source</a></div>
		</div>
	</body>
</html>